// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BLACKLIST_MOD_PROTO_BLACKLIST_H_
#define FLATBUFFERS_GENERATED_BLACKLIST_MOD_PROTO_BLACKLIST_H_

#include "flatbuffers/flatbuffers.h"

#include "uuid_addition.h"
#include "uuid_generated.h"

namespace Mod {
namespace proto {
namespace blacklist {

struct BlacklistOp;
struct BlacklistOpBuilder;
struct BlacklistOpT;

struct AddUUID;
struct AddUUIDBuilder;
struct AddUUIDT;

struct RemoveUUID;
struct RemoveUUIDBuilder;
struct RemoveUUIDT;

struct AddXUID;
struct AddXUIDBuilder;
struct AddXUIDT;

struct RemoveXUID;
struct RemoveXUIDBuilder;
struct RemoveXUIDT;

struct AddNAME;
struct AddNAMEBuilder;
struct AddNAMET;

struct RemoveNAME;
struct RemoveNAMEBuilder;
struct RemoveNAMET;

enum class Op : uint8_t {
  NONE = 0,
  AddUUID = 1,
  RemoveUUID = 2,
  AddXUID = 3,
  RemoveXUID = 4,
  AddNAME = 5,
  RemoveNAME = 6,
  MIN = NONE,
  MAX = RemoveNAME
};

inline const Op (&EnumValuesOp())[7] {
  static const Op values[] = {
    Op::NONE,
    Op::AddUUID,
    Op::RemoveUUID,
    Op::AddXUID,
    Op::RemoveXUID,
    Op::AddNAME,
    Op::RemoveNAME
  };
  return values;
}

inline const char * const *EnumNamesOp() {
  static const char * const names[8] = {
    "NONE",
    "AddUUID",
    "RemoveUUID",
    "AddXUID",
    "RemoveXUID",
    "AddNAME",
    "RemoveNAME",
    nullptr
  };
  return names;
}

inline const char *EnumNameOp(Op e) {
  if (flatbuffers::IsOutRange(e, Op::NONE, Op::RemoveNAME)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOp()[index];
}

template<typename T> struct OpTraits {
  static const Op enum_value = Op::NONE;
};

template<> struct OpTraits<Mod::proto::blacklist::AddUUID> {
  static const Op enum_value = Op::AddUUID;
};

template<> struct OpTraits<Mod::proto::blacklist::RemoveUUID> {
  static const Op enum_value = Op::RemoveUUID;
};

template<> struct OpTraits<Mod::proto::blacklist::AddXUID> {
  static const Op enum_value = Op::AddXUID;
};

template<> struct OpTraits<Mod::proto::blacklist::RemoveXUID> {
  static const Op enum_value = Op::RemoveXUID;
};

template<> struct OpTraits<Mod::proto::blacklist::AddNAME> {
  static const Op enum_value = Op::AddNAME;
};

template<> struct OpTraits<Mod::proto::blacklist::RemoveNAME> {
  static const Op enum_value = Op::RemoveNAME;
};

struct OpUnion {
  Op type;
  void *value;

  OpUnion() : type(Op::NONE), value(nullptr) {}
  OpUnion(OpUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Op::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  OpUnion(const OpUnion &);
  OpUnion &operator=(const OpUnion &u)
    { OpUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  OpUnion &operator=(OpUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~OpUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = OpTraits<typename RT::TableType>::enum_value;
    if (type != Op::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Op type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Mod::proto::blacklist::AddUUIDT *AsAddUUID() {
    return type == Op::AddUUID ?
      reinterpret_cast<Mod::proto::blacklist::AddUUIDT *>(value) : nullptr;
  }
  const Mod::proto::blacklist::AddUUIDT *AsAddUUID() const {
    return type == Op::AddUUID ?
      reinterpret_cast<const Mod::proto::blacklist::AddUUIDT *>(value) : nullptr;
  }
  Mod::proto::blacklist::RemoveUUIDT *AsRemoveUUID() {
    return type == Op::RemoveUUID ?
      reinterpret_cast<Mod::proto::blacklist::RemoveUUIDT *>(value) : nullptr;
  }
  const Mod::proto::blacklist::RemoveUUIDT *AsRemoveUUID() const {
    return type == Op::RemoveUUID ?
      reinterpret_cast<const Mod::proto::blacklist::RemoveUUIDT *>(value) : nullptr;
  }
  Mod::proto::blacklist::AddXUIDT *AsAddXUID() {
    return type == Op::AddXUID ?
      reinterpret_cast<Mod::proto::blacklist::AddXUIDT *>(value) : nullptr;
  }
  const Mod::proto::blacklist::AddXUIDT *AsAddXUID() const {
    return type == Op::AddXUID ?
      reinterpret_cast<const Mod::proto::blacklist::AddXUIDT *>(value) : nullptr;
  }
  Mod::proto::blacklist::RemoveXUIDT *AsRemoveXUID() {
    return type == Op::RemoveXUID ?
      reinterpret_cast<Mod::proto::blacklist::RemoveXUIDT *>(value) : nullptr;
  }
  const Mod::proto::blacklist::RemoveXUIDT *AsRemoveXUID() const {
    return type == Op::RemoveXUID ?
      reinterpret_cast<const Mod::proto::blacklist::RemoveXUIDT *>(value) : nullptr;
  }
  Mod::proto::blacklist::AddNAMET *AsAddNAME() {
    return type == Op::AddNAME ?
      reinterpret_cast<Mod::proto::blacklist::AddNAMET *>(value) : nullptr;
  }
  const Mod::proto::blacklist::AddNAMET *AsAddNAME() const {
    return type == Op::AddNAME ?
      reinterpret_cast<const Mod::proto::blacklist::AddNAMET *>(value) : nullptr;
  }
  Mod::proto::blacklist::RemoveNAMET *AsRemoveNAME() {
    return type == Op::RemoveNAME ?
      reinterpret_cast<Mod::proto::blacklist::RemoveNAMET *>(value) : nullptr;
  }
  const Mod::proto::blacklist::RemoveNAMET *AsRemoveNAME() const {
    return type == Op::RemoveNAME ?
      reinterpret_cast<const Mod::proto::blacklist::RemoveNAMET *>(value) : nullptr;
  }
};

bool VerifyOp(flatbuffers::Verifier &verifier, const void *obj, Op type);
bool VerifyOpVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct BlacklistOpT : public flatbuffers::NativeTable {
  typedef BlacklistOp TableType;
  std::vector<Mod::proto::blacklist::OpUnion> ops;
  BlacklistOpT() {
  }
};

struct BlacklistOp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BlacklistOpT NativeTableType;
  typedef BlacklistOpBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPS_TYPE = 4,
    VT_OPS = 6
  };
  const flatbuffers::Vector<uint8_t> *ops_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_OPS_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *ops() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_OPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OPS_TYPE) &&
           verifier.VerifyVector(ops_type()) &&
           VerifyOffset(verifier, VT_OPS) &&
           verifier.VerifyVector(ops()) &&
           VerifyOpVector(verifier, ops(), ops_type()) &&
           verifier.EndTable();
  }
  BlacklistOpT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BlacklistOpT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BlacklistOp> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlacklistOpT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BlacklistOpBuilder {
  typedef BlacklistOp Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ops_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ops_type) {
    fbb_.AddOffset(BlacklistOp::VT_OPS_TYPE, ops_type);
  }
  void add_ops(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> ops) {
    fbb_.AddOffset(BlacklistOp::VT_OPS, ops);
  }
  explicit BlacklistOpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlacklistOpBuilder &operator=(const BlacklistOpBuilder &);
  flatbuffers::Offset<BlacklistOp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlacklistOp>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlacklistOp> CreateBlacklistOp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ops_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> ops = 0) {
  BlacklistOpBuilder builder_(_fbb);
  builder_.add_ops(ops);
  builder_.add_ops_type(ops_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<BlacklistOp> CreateBlacklistOpDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *ops_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *ops = nullptr) {
  auto ops_type__ = ops_type ? _fbb.CreateVector<uint8_t>(*ops_type) : 0;
  auto ops__ = ops ? _fbb.CreateVector<flatbuffers::Offset<void>>(*ops) : 0;
  return Mod::proto::blacklist::CreateBlacklistOp(
      _fbb,
      ops_type__,
      ops__);
}

flatbuffers::Offset<BlacklistOp> CreateBlacklistOp(flatbuffers::FlatBufferBuilder &_fbb, const BlacklistOpT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddUUIDT : public flatbuffers::NativeTable {
  typedef AddUUID TableType;
  mce::UUID value;
  std::string name;
  std::string reason;
  std::string op;
  AddUUIDT() {
  }
};

struct AddUUID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddUUIDT NativeTableType;
  typedef AddUUIDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_NAME = 6,
    VT_REASON = 8,
    VT_OP = 10
  };
  const Mod::proto::UUID *value() const {
    return GetStruct<const Mod::proto::UUID *>(VT_VALUE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *reason() const {
    return GetPointer<const flatbuffers::String *>(VT_REASON);
  }
  const flatbuffers::String *op() const {
    return GetPointer<const flatbuffers::String *>(VT_OP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<Mod::proto::UUID>(verifier, VT_VALUE) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_REASON) &&
           verifier.VerifyString(reason()) &&
           VerifyOffset(verifier, VT_OP) &&
           verifier.VerifyString(op()) &&
           verifier.EndTable();
  }
  AddUUIDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddUUIDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AddUUID> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddUUIDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddUUIDBuilder {
  typedef AddUUID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(const Mod::proto::UUID *value) {
    fbb_.AddStruct(AddUUID::VT_VALUE, value);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(AddUUID::VT_NAME, name);
  }
  void add_reason(flatbuffers::Offset<flatbuffers::String> reason) {
    fbb_.AddOffset(AddUUID::VT_REASON, reason);
  }
  void add_op(flatbuffers::Offset<flatbuffers::String> op) {
    fbb_.AddOffset(AddUUID::VT_OP, op);
  }
  explicit AddUUIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddUUIDBuilder &operator=(const AddUUIDBuilder &);
  flatbuffers::Offset<AddUUID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddUUID>(end);
    fbb_.Required(o, AddUUID::VT_VALUE);
    return o;
  }
};

inline flatbuffers::Offset<AddUUID> CreateAddUUID(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Mod::proto::UUID *value = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> reason = 0,
    flatbuffers::Offset<flatbuffers::String> op = 0) {
  AddUUIDBuilder builder_(_fbb);
  builder_.add_op(op);
  builder_.add_reason(reason);
  builder_.add_name(name);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<AddUUID> CreateAddUUIDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Mod::proto::UUID *value = 0,
    const char *name = nullptr,
    const char *reason = nullptr,
    const char *op = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto reason__ = reason ? _fbb.CreateString(reason) : 0;
  auto op__ = op ? _fbb.CreateString(op) : 0;
  return Mod::proto::blacklist::CreateAddUUID(
      _fbb,
      value,
      name__,
      reason__,
      op__);
}

flatbuffers::Offset<AddUUID> CreateAddUUID(flatbuffers::FlatBufferBuilder &_fbb, const AddUUIDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RemoveUUIDT : public flatbuffers::NativeTable {
  typedef RemoveUUID TableType;
  mce::UUID value;
  RemoveUUIDT() {
  }
};

struct RemoveUUID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RemoveUUIDT NativeTableType;
  typedef RemoveUUIDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const Mod::proto::UUID *value() const {
    return GetStruct<const Mod::proto::UUID *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<Mod::proto::UUID>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
  RemoveUUIDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RemoveUUIDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RemoveUUID> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RemoveUUIDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RemoveUUIDBuilder {
  typedef RemoveUUID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(const Mod::proto::UUID *value) {
    fbb_.AddStruct(RemoveUUID::VT_VALUE, value);
  }
  explicit RemoveUUIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemoveUUIDBuilder &operator=(const RemoveUUIDBuilder &);
  flatbuffers::Offset<RemoveUUID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RemoveUUID>(end);
    fbb_.Required(o, RemoveUUID::VT_VALUE);
    return o;
  }
};

inline flatbuffers::Offset<RemoveUUID> CreateRemoveUUID(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Mod::proto::UUID *value = 0) {
  RemoveUUIDBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

flatbuffers::Offset<RemoveUUID> CreateRemoveUUID(flatbuffers::FlatBufferBuilder &_fbb, const RemoveUUIDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddXUIDT : public flatbuffers::NativeTable {
  typedef AddXUID TableType;
  uint64_t value;
  std::string name;
  std::string reason;
  std::string op;
  AddXUIDT()
      : value(0) {
  }
};

struct AddXUID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddXUIDT NativeTableType;
  typedef AddXUIDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_NAME = 6,
    VT_REASON = 8,
    VT_OP = 10
  };
  uint64_t value() const {
    return GetField<uint64_t>(VT_VALUE, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *reason() const {
    return GetPointer<const flatbuffers::String *>(VT_REASON);
  }
  const flatbuffers::String *op() const {
    return GetPointer<const flatbuffers::String *>(VT_OP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VALUE) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_REASON) &&
           verifier.VerifyString(reason()) &&
           VerifyOffset(verifier, VT_OP) &&
           verifier.VerifyString(op()) &&
           verifier.EndTable();
  }
  AddXUIDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddXUIDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AddXUID> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddXUIDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddXUIDBuilder {
  typedef AddXUID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint64_t value) {
    fbb_.AddElement<uint64_t>(AddXUID::VT_VALUE, value, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(AddXUID::VT_NAME, name);
  }
  void add_reason(flatbuffers::Offset<flatbuffers::String> reason) {
    fbb_.AddOffset(AddXUID::VT_REASON, reason);
  }
  void add_op(flatbuffers::Offset<flatbuffers::String> op) {
    fbb_.AddOffset(AddXUID::VT_OP, op);
  }
  explicit AddXUIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddXUIDBuilder &operator=(const AddXUIDBuilder &);
  flatbuffers::Offset<AddXUID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddXUID>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddXUID> CreateAddXUID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t value = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> reason = 0,
    flatbuffers::Offset<flatbuffers::String> op = 0) {
  AddXUIDBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_op(op);
  builder_.add_reason(reason);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<AddXUID> CreateAddXUIDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t value = 0,
    const char *name = nullptr,
    const char *reason = nullptr,
    const char *op = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto reason__ = reason ? _fbb.CreateString(reason) : 0;
  auto op__ = op ? _fbb.CreateString(op) : 0;
  return Mod::proto::blacklist::CreateAddXUID(
      _fbb,
      value,
      name__,
      reason__,
      op__);
}

flatbuffers::Offset<AddXUID> CreateAddXUID(flatbuffers::FlatBufferBuilder &_fbb, const AddXUIDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RemoveXUIDT : public flatbuffers::NativeTable {
  typedef RemoveXUID TableType;
  uint64_t value;
  RemoveXUIDT()
      : value(0) {
  }
};

struct RemoveXUID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RemoveXUIDT NativeTableType;
  typedef RemoveXUIDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint64_t value() const {
    return GetField<uint64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
  RemoveXUIDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RemoveXUIDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RemoveXUID> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RemoveXUIDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RemoveXUIDBuilder {
  typedef RemoveXUID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint64_t value) {
    fbb_.AddElement<uint64_t>(RemoveXUID::VT_VALUE, value, 0);
  }
  explicit RemoveXUIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemoveXUIDBuilder &operator=(const RemoveXUIDBuilder &);
  flatbuffers::Offset<RemoveXUID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RemoveXUID>(end);
    return o;
  }
};

inline flatbuffers::Offset<RemoveXUID> CreateRemoveXUID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t value = 0) {
  RemoveXUIDBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

flatbuffers::Offset<RemoveXUID> CreateRemoveXUID(flatbuffers::FlatBufferBuilder &_fbb, const RemoveXUIDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddNAMET : public flatbuffers::NativeTable {
  typedef AddNAME TableType;
  std::string value;
  std::string reason;
  std::string op;
  AddNAMET() {
  }
};

struct AddNAME FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddNAMET NativeTableType;
  typedef AddNAMEBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_REASON = 6,
    VT_OP = 8
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  const flatbuffers::String *reason() const {
    return GetPointer<const flatbuffers::String *>(VT_REASON);
  }
  const flatbuffers::String *op() const {
    return GetPointer<const flatbuffers::String *>(VT_OP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           VerifyOffset(verifier, VT_REASON) &&
           verifier.VerifyString(reason()) &&
           VerifyOffset(verifier, VT_OP) &&
           verifier.VerifyString(op()) &&
           verifier.EndTable();
  }
  AddNAMET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddNAMET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AddNAME> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddNAMET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddNAMEBuilder {
  typedef AddNAME Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(AddNAME::VT_VALUE, value);
  }
  void add_reason(flatbuffers::Offset<flatbuffers::String> reason) {
    fbb_.AddOffset(AddNAME::VT_REASON, reason);
  }
  void add_op(flatbuffers::Offset<flatbuffers::String> op) {
    fbb_.AddOffset(AddNAME::VT_OP, op);
  }
  explicit AddNAMEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddNAMEBuilder &operator=(const AddNAMEBuilder &);
  flatbuffers::Offset<AddNAME> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddNAME>(end);
    fbb_.Required(o, AddNAME::VT_VALUE);
    return o;
  }
};

inline flatbuffers::Offset<AddNAME> CreateAddNAME(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0,
    flatbuffers::Offset<flatbuffers::String> reason = 0,
    flatbuffers::Offset<flatbuffers::String> op = 0) {
  AddNAMEBuilder builder_(_fbb);
  builder_.add_op(op);
  builder_.add_reason(reason);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<AddNAME> CreateAddNAMEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr,
    const char *reason = nullptr,
    const char *op = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  auto reason__ = reason ? _fbb.CreateString(reason) : 0;
  auto op__ = op ? _fbb.CreateString(op) : 0;
  return Mod::proto::blacklist::CreateAddNAME(
      _fbb,
      value__,
      reason__,
      op__);
}

flatbuffers::Offset<AddNAME> CreateAddNAME(flatbuffers::FlatBufferBuilder &_fbb, const AddNAMET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RemoveNAMET : public flatbuffers::NativeTable {
  typedef RemoveNAME TableType;
  std::string value;
  RemoveNAMET() {
  }
};

struct RemoveNAME FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RemoveNAMET NativeTableType;
  typedef RemoveNAMEBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
  RemoveNAMET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RemoveNAMET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RemoveNAME> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RemoveNAMET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RemoveNAMEBuilder {
  typedef RemoveNAME Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(RemoveNAME::VT_VALUE, value);
  }
  explicit RemoveNAMEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemoveNAMEBuilder &operator=(const RemoveNAMEBuilder &);
  flatbuffers::Offset<RemoveNAME> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RemoveNAME>(end);
    fbb_.Required(o, RemoveNAME::VT_VALUE);
    return o;
  }
};

inline flatbuffers::Offset<RemoveNAME> CreateRemoveNAME(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  RemoveNAMEBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<RemoveNAME> CreateRemoveNAMEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return Mod::proto::blacklist::CreateRemoveNAME(
      _fbb,
      value__);
}

flatbuffers::Offset<RemoveNAME> CreateRemoveNAME(flatbuffers::FlatBufferBuilder &_fbb, const RemoveNAMET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline BlacklistOpT *BlacklistOp::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Mod::proto::blacklist::BlacklistOpT> _o = std::unique_ptr<Mod::proto::blacklist::BlacklistOpT>(new BlacklistOpT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BlacklistOp::UnPackTo(BlacklistOpT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ops_type(); if (_e) { _o->ops.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ops[_i].type = static_cast<Mod::proto::blacklist::Op>(_e->Get(_i)); } } }
  { auto _e = ops(); if (_e) { _o->ops.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ops[_i].value = Mod::proto::blacklist::OpUnion::UnPack(_e->Get(_i), ops_type()->GetEnum<Op>(_i), _resolver); } } }
}

inline flatbuffers::Offset<BlacklistOp> BlacklistOp::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlacklistOpT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBlacklistOp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BlacklistOp> CreateBlacklistOp(flatbuffers::FlatBufferBuilder &_fbb, const BlacklistOpT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BlacklistOpT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ops_type = _o->ops.size() ? _fbb.CreateVector<uint8_t>(_o->ops.size(), [](size_t i, _VectorArgs *__va) { return static_cast<uint8_t>(__va->__o->ops[i].type); }, &_va) : 0;
  auto _ops = _o->ops.size() ? _fbb.CreateVector<flatbuffers::Offset<void>>(_o->ops.size(), [](size_t i, _VectorArgs *__va) { return __va->__o->ops[i].Pack(*__va->__fbb, __va->__rehasher); }, &_va) : 0;
  return Mod::proto::blacklist::CreateBlacklistOp(
      _fbb,
      _ops_type,
      _ops);
}

inline AddUUIDT *AddUUID::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Mod::proto::blacklist::AddUUIDT> _o = std::unique_ptr<Mod::proto::blacklist::AddUUIDT>(new AddUUIDT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AddUUID::UnPackTo(AddUUIDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); if (_e) _o->value = flatbuffers::UnPack(*_e); }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = reason(); if (_e) _o->reason = _e->str(); }
  { auto _e = op(); if (_e) _o->op = _e->str(); }
}

inline flatbuffers::Offset<AddUUID> AddUUID::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddUUIDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddUUID(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddUUID> CreateAddUUID(flatbuffers::FlatBufferBuilder &_fbb, const AddUUIDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddUUIDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = flatbuffers::Pack(_o->value);
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _reason = _o->reason.empty() ? 0 : _fbb.CreateString(_o->reason);
  auto _op = _o->op.empty() ? 0 : _fbb.CreateString(_o->op);
  return Mod::proto::blacklist::CreateAddUUID(
      _fbb,
      &_value,
      _name,
      _reason,
      _op);
}

inline RemoveUUIDT *RemoveUUID::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Mod::proto::blacklist::RemoveUUIDT> _o = std::unique_ptr<Mod::proto::blacklist::RemoveUUIDT>(new RemoveUUIDT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RemoveUUID::UnPackTo(RemoveUUIDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); if (_e) _o->value = flatbuffers::UnPack(*_e); }
}

inline flatbuffers::Offset<RemoveUUID> RemoveUUID::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RemoveUUIDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRemoveUUID(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RemoveUUID> CreateRemoveUUID(flatbuffers::FlatBufferBuilder &_fbb, const RemoveUUIDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RemoveUUIDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = flatbuffers::Pack(_o->value);
  return Mod::proto::blacklist::CreateRemoveUUID(
      _fbb,
      &_value);
}

inline AddXUIDT *AddXUID::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Mod::proto::blacklist::AddXUIDT> _o = std::unique_ptr<Mod::proto::blacklist::AddXUIDT>(new AddXUIDT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AddXUID::UnPackTo(AddXUIDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); _o->value = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = reason(); if (_e) _o->reason = _e->str(); }
  { auto _e = op(); if (_e) _o->op = _e->str(); }
}

inline flatbuffers::Offset<AddXUID> AddXUID::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddXUIDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddXUID(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddXUID> CreateAddXUID(flatbuffers::FlatBufferBuilder &_fbb, const AddXUIDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddXUIDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _reason = _o->reason.empty() ? 0 : _fbb.CreateString(_o->reason);
  auto _op = _o->op.empty() ? 0 : _fbb.CreateString(_o->op);
  return Mod::proto::blacklist::CreateAddXUID(
      _fbb,
      _value,
      _name,
      _reason,
      _op);
}

inline RemoveXUIDT *RemoveXUID::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Mod::proto::blacklist::RemoveXUIDT> _o = std::unique_ptr<Mod::proto::blacklist::RemoveXUIDT>(new RemoveXUIDT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RemoveXUID::UnPackTo(RemoveXUIDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); _o->value = _e; }
}

inline flatbuffers::Offset<RemoveXUID> RemoveXUID::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RemoveXUIDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRemoveXUID(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RemoveXUID> CreateRemoveXUID(flatbuffers::FlatBufferBuilder &_fbb, const RemoveXUIDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RemoveXUIDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value;
  return Mod::proto::blacklist::CreateRemoveXUID(
      _fbb,
      _value);
}

inline AddNAMET *AddNAME::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Mod::proto::blacklist::AddNAMET> _o = std::unique_ptr<Mod::proto::blacklist::AddNAMET>(new AddNAMET());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AddNAME::UnPackTo(AddNAMET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); if (_e) _o->value = _e->str(); }
  { auto _e = reason(); if (_e) _o->reason = _e->str(); }
  { auto _e = op(); if (_e) _o->op = _e->str(); }
}

inline flatbuffers::Offset<AddNAME> AddNAME::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddNAMET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddNAME(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddNAME> CreateAddNAME(flatbuffers::FlatBufferBuilder &_fbb, const AddNAMET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddNAMET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _fbb.CreateString(_o->value);
  auto _reason = _o->reason.empty() ? 0 : _fbb.CreateString(_o->reason);
  auto _op = _o->op.empty() ? 0 : _fbb.CreateString(_o->op);
  return Mod::proto::blacklist::CreateAddNAME(
      _fbb,
      _value,
      _reason,
      _op);
}

inline RemoveNAMET *RemoveNAME::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<Mod::proto::blacklist::RemoveNAMET> _o = std::unique_ptr<Mod::proto::blacklist::RemoveNAMET>(new RemoveNAMET());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RemoveNAME::UnPackTo(RemoveNAMET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); if (_e) _o->value = _e->str(); }
}

inline flatbuffers::Offset<RemoveNAME> RemoveNAME::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RemoveNAMET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRemoveNAME(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RemoveNAME> CreateRemoveNAME(flatbuffers::FlatBufferBuilder &_fbb, const RemoveNAMET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RemoveNAMET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _fbb.CreateString(_o->value);
  return Mod::proto::blacklist::CreateRemoveNAME(
      _fbb,
      _value);
}

inline bool VerifyOp(flatbuffers::Verifier &verifier, const void *obj, Op type) {
  switch (type) {
    case Op::NONE: {
      return true;
    }
    case Op::AddUUID: {
      auto ptr = reinterpret_cast<const Mod::proto::blacklist::AddUUID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Op::RemoveUUID: {
      auto ptr = reinterpret_cast<const Mod::proto::blacklist::RemoveUUID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Op::AddXUID: {
      auto ptr = reinterpret_cast<const Mod::proto::blacklist::AddXUID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Op::RemoveXUID: {
      auto ptr = reinterpret_cast<const Mod::proto::blacklist::RemoveXUID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Op::AddNAME: {
      auto ptr = reinterpret_cast<const Mod::proto::blacklist::AddNAME *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Op::RemoveNAME: {
      auto ptr = reinterpret_cast<const Mod::proto::blacklist::RemoveNAME *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyOpVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOp(
        verifier,  values->Get(i), types->GetEnum<Op>(i))) {
      return false;
    }
  }
  return true;
}

inline void *OpUnion::UnPack(const void *obj, Op type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Op::AddUUID: {
      auto ptr = reinterpret_cast<const Mod::proto::blacklist::AddUUID *>(obj);
      return ptr->UnPack(resolver);
    }
    case Op::RemoveUUID: {
      auto ptr = reinterpret_cast<const Mod::proto::blacklist::RemoveUUID *>(obj);
      return ptr->UnPack(resolver);
    }
    case Op::AddXUID: {
      auto ptr = reinterpret_cast<const Mod::proto::blacklist::AddXUID *>(obj);
      return ptr->UnPack(resolver);
    }
    case Op::RemoveXUID: {
      auto ptr = reinterpret_cast<const Mod::proto::blacklist::RemoveXUID *>(obj);
      return ptr->UnPack(resolver);
    }
    case Op::AddNAME: {
      auto ptr = reinterpret_cast<const Mod::proto::blacklist::AddNAME *>(obj);
      return ptr->UnPack(resolver);
    }
    case Op::RemoveNAME: {
      auto ptr = reinterpret_cast<const Mod::proto::blacklist::RemoveNAME *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> OpUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Op::AddUUID: {
      auto ptr = reinterpret_cast<const Mod::proto::blacklist::AddUUIDT *>(value);
      return CreateAddUUID(_fbb, ptr, _rehasher).Union();
    }
    case Op::RemoveUUID: {
      auto ptr = reinterpret_cast<const Mod::proto::blacklist::RemoveUUIDT *>(value);
      return CreateRemoveUUID(_fbb, ptr, _rehasher).Union();
    }
    case Op::AddXUID: {
      auto ptr = reinterpret_cast<const Mod::proto::blacklist::AddXUIDT *>(value);
      return CreateAddXUID(_fbb, ptr, _rehasher).Union();
    }
    case Op::RemoveXUID: {
      auto ptr = reinterpret_cast<const Mod::proto::blacklist::RemoveXUIDT *>(value);
      return CreateRemoveXUID(_fbb, ptr, _rehasher).Union();
    }
    case Op::AddNAME: {
      auto ptr = reinterpret_cast<const Mod::proto::blacklist::AddNAMET *>(value);
      return CreateAddNAME(_fbb, ptr, _rehasher).Union();
    }
    case Op::RemoveNAME: {
      auto ptr = reinterpret_cast<const Mod::proto::blacklist::RemoveNAMET *>(value);
      return CreateRemoveNAME(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline OpUnion::OpUnion(const OpUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Op::AddUUID: {
      value = new Mod::proto::blacklist::AddUUIDT(*reinterpret_cast<Mod::proto::blacklist::AddUUIDT *>(u.value));
      break;
    }
    case Op::RemoveUUID: {
      value = new Mod::proto::blacklist::RemoveUUIDT(*reinterpret_cast<Mod::proto::blacklist::RemoveUUIDT *>(u.value));
      break;
    }
    case Op::AddXUID: {
      value = new Mod::proto::blacklist::AddXUIDT(*reinterpret_cast<Mod::proto::blacklist::AddXUIDT *>(u.value));
      break;
    }
    case Op::RemoveXUID: {
      value = new Mod::proto::blacklist::RemoveXUIDT(*reinterpret_cast<Mod::proto::blacklist::RemoveXUIDT *>(u.value));
      break;
    }
    case Op::AddNAME: {
      value = new Mod::proto::blacklist::AddNAMET(*reinterpret_cast<Mod::proto::blacklist::AddNAMET *>(u.value));
      break;
    }
    case Op::RemoveNAME: {
      value = new Mod::proto::blacklist::RemoveNAMET(*reinterpret_cast<Mod::proto::blacklist::RemoveNAMET *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void OpUnion::Reset() {
  switch (type) {
    case Op::AddUUID: {
      auto ptr = reinterpret_cast<Mod::proto::blacklist::AddUUIDT *>(value);
      delete ptr;
      break;
    }
    case Op::RemoveUUID: {
      auto ptr = reinterpret_cast<Mod::proto::blacklist::RemoveUUIDT *>(value);
      delete ptr;
      break;
    }
    case Op::AddXUID: {
      auto ptr = reinterpret_cast<Mod::proto::blacklist::AddXUIDT *>(value);
      delete ptr;
      break;
    }
    case Op::RemoveXUID: {
      auto ptr = reinterpret_cast<Mod::proto::blacklist::RemoveXUIDT *>(value);
      delete ptr;
      break;
    }
    case Op::AddNAME: {
      auto ptr = reinterpret_cast<Mod::proto::blacklist::AddNAMET *>(value);
      delete ptr;
      break;
    }
    case Op::RemoveNAME: {
      auto ptr = reinterpret_cast<Mod::proto::blacklist::RemoveNAMET *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Op::NONE;
}

inline const Mod::proto::blacklist::BlacklistOp *GetBlacklistOp(const void *buf) {
  return flatbuffers::GetRoot<Mod::proto::blacklist::BlacklistOp>(buf);
}

inline const Mod::proto::blacklist::BlacklistOp *GetSizePrefixedBlacklistOp(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Mod::proto::blacklist::BlacklistOp>(buf);
}

inline bool VerifyBlacklistOpBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Mod::proto::blacklist::BlacklistOp>(nullptr);
}

inline bool VerifySizePrefixedBlacklistOpBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Mod::proto::blacklist::BlacklistOp>(nullptr);
}

inline void FinishBlacklistOpBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Mod::proto::blacklist::BlacklistOp> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBlacklistOpBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Mod::proto::blacklist::BlacklistOp> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<Mod::proto::blacklist::BlacklistOpT> UnPackBlacklistOp(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Mod::proto::blacklist::BlacklistOpT>(GetBlacklistOp(buf)->UnPack(res));
}

inline std::unique_ptr<Mod::proto::blacklist::BlacklistOpT> UnPackSizePrefixedBlacklistOp(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Mod::proto::blacklist::BlacklistOpT>(GetSizePrefixedBlacklistOp(buf)->UnPack(res));
}

}  // namespace blacklist
}  // namespace proto
}  // namespace Mod

#endif  // FLATBUFFERS_GENERATED_BLACKLIST_MOD_PROTO_BLACKLIST_H_
